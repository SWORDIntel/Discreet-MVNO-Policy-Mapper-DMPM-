import base64
import logging
import os

# Get a logger instance
logger = logging.getLogger(__name__)

class MockFernet:
    """
    A mock implementation of the Fernet interface using base64 encoding.
    This is intended for use when the cryptography library is unavailable or
    when operating in a degraded environment where real encryption is not desired.
    The API matches cryptography.fernet.Fernet for encrypt, decrypt, and generate_key.
    """
    def __init__(self, key: bytes):
        """
        Initializes MockFernet with a key. The key is not used for actual
        encryption in this mock implementation but is kept for API compatibility.
        Args:
            key (bytes): A key, typically generated by generate_key().
        """
        if not isinstance(key, bytes):
            raise TypeError("MockFernet key must be bytes.")
        # Key is stored but not used for base64 operations directly
        self.key = key
        logger.info("MockFernet initialized. Encryption operations will use base64.")

    def encrypt(self, data: bytes) -> bytes:
        """
        "Encrypts" data using base64 encoding.
        Args:
            data (bytes): The plaintext data to encrypt.
        Returns:
            bytes: The base64 encoded data.
        """
        if not isinstance(data, bytes):
            raise TypeError("Data to encrypt must be bytes.")
        return base64.urlsafe_b64encode(data)

    def decrypt(self, token: bytes) -> bytes:
        """
        "Decrypts" data using base64 decoding.
        Args:
            token (bytes): The base64 encoded data to decrypt.
        Returns:
            bytes: The decoded data.
        Raises:
            ValueError: If the token is not valid base64.
        """
        if not isinstance(token, bytes):
            raise TypeError("Token to decrypt must be bytes.")
        try:
            return base64.urlsafe_b64decode(token)
        except base64.binascii.Error as e: # Catch potential decoding errors
            logger.error(f"MockFernet decryption error (invalid base64 token): {e}")
            # Fernet raises InvalidToken, but since we don't have that without cryptography,
            # we'll raise a ValueError or let the original error propagate if more appropriate.
            # For now, re-raising as ValueError to indicate bad input.
            raise ValueError("Invalid base64 token for MockFernet decryption.") from e


    @staticmethod
    def generate_key() -> bytes:
        """
        Generates a dummy "key" suitable for MockFernet.
        Since base64 doesn't use a key in the same way Fernet does,
        this returns a fixed or randomly generated (but not cryptographically secure)
        byte string, primarily for API compatibility.
        Returns:
            bytes: A 32-byte URL-safe base64 encoded string.
        """
        # Return a new random 32-byte string, base64 encoded, to mimic a Fernet key format.
        # This isn't strictly necessary for base64, but makes it look like a Fernet key.
        return base64.urlsafe_b64encode(os.urandom(32))

class CryptoProvider:
    """
    Provides cryptographic operations, abstracting the underlying implementation.
    It can operate in 'auto', 'fernet', or 'mock' mode.
    - 'auto': Tries to use cryptography.fernet.Fernet, falls back to MockFernet if unavailable.
    - 'fernet': Forces use of cryptography.fernet.Fernet, raises error if unavailable.
    - 'mock': Forces use of MockFernet.
    """
    def __init__(self, mode: str = "auto", key: bytes = None):
        """
        Initializes the CryptoProvider.
        Args:
            mode (str): The desired encryption mode: "auto", "fernet", or "mock".
            key (bytes, optional): The encryption key to use. If None, a new key
                                   will be generated on the first use or when
                                   generate_key() is explicitly called.
        """
        self.mode = mode.lower()
        self._key = key
        self._cipher_suite = None
        self.effective_mode = None # Will be 'fernet' or 'mock'

        self._initialize_cipher()

    def _initialize_cipher(self):
        """Initializes the cipher suite based on the configured mode and available libraries."""
        Fernet_imported = None
        if self.mode in ["auto", "fernet"]:
            try:
                from cryptography.fernet import Fernet as RealFernet
                Fernet_imported = RealFernet
                logger.info("Successfully imported cryptography.fernet.Fernet.")
            except ImportError:
                logger.warning("Cryptography library not found or Fernet could not be imported.")
                if self.mode == "fernet":
                    raise ImportError("Encryption mode set to 'fernet' but cryptography library is unavailable.")

        if Fernet_imported and (self.mode == "fernet" or self.mode == "auto"):
            self.effective_mode = "fernet"
            if not self._key:
                self._key = Fernet_imported.generate_key()
                logger.info("CryptoProvider generated a new Fernet key.")
            self._cipher_suite = Fernet_imported(self._key)
            logger.info("CryptoProvider initialized with Fernet (real encryption).")
        else: # Fallback to mock for 'auto' if Fernet failed, or if mode is 'mock'
            self.effective_mode = "mock"
            if not self._key:
                self._key = MockFernet.generate_key() # Generate a mock key
                logger.info("CryptoProvider generated a new MockFernet key.")
            self._cipher_suite = MockFernet(self._key) # Pass the key to MockFernet
            logger.warning("CryptoProvider initialized with MockFernet (base64 encoding).")

    def generate_key(self) -> bytes:
        """
        Generates a new encryption key using the active provider's method.
        This key is also set as the current key for this CryptoProvider instance.
        Returns:
            bytes: The generated key.
        """
        if self.effective_mode == "fernet":
            from cryptography.fernet import Fernet as RealFernet # Re-import locally
            self._key = RealFernet.generate_key()
        else:
            self._key = MockFernet.generate_key()

        # Re-initialize the cipher suite with the new key
        self._initialize_cipher()
        logger.info(f"CryptoProvider generated and set a new key using {self.effective_mode} mode.")
        return self._key

    def get_cipher_suite(self, key: bytes = None):
        """
        Returns a cipher suite instance (Fernet or MockFernet) initialized with the given key.
        If no key is provided, uses the CryptoProvider's current key.
        This is useful if an external key needs to be used for a specific operation.

        Args:
            key (bytes, optional): The key to initialize the cipher suite with.

        Returns:
            An instance of Fernet or MockFernet.
        """
        target_key = key if key else self._key
        if not target_key:
            # This should ideally not happen if _initialize_cipher always sets a key
            logger.warning("No key available for get_cipher_suite, generating a new one.")
            target_key = self.generate_key() # This will also re-init self._cipher_suite

        if self.effective_mode == "fernet":
            from cryptography.fernet import Fernet as RealFernet
            return RealFernet(target_key)
        else:
            return MockFernet(target_key)

    @property
    def key(self) -> bytes:
        """Returns the current encryption key."""
        if not self._key:
            # This case implies the instance was created without a key and no operation
            # requiring a key (like encrypt/decrypt, or explicit generate_key) has been called yet.
            # We should generate one to ensure a key is always available after first access.
            logger.info("Key accessed before explicit generation; generating one now.")
            self.generate_key() # This will set self._key and self._cipher_suite
        return self._key

    def encrypt(self, data: bytes) -> bytes:
        """
        Encrypts data using the active cipher suite.
        Args:
            data (bytes): Plaintext data to encrypt.
        Returns:
            bytes: Encrypted data.
        """
        if not self._cipher_suite:
            logger.error("Cipher suite not initialized. Cannot encrypt.")
            raise RuntimeError("CryptoProvider cipher suite not initialized.")
        return self._cipher_suite.encrypt(data)

    def decrypt(self, token: bytes) -> bytes:
        """
        Decrypts data using the active cipher suite.
        Args:
            token (bytes): Encrypted data to decrypt.
        Returns:
            bytes: Plaintext data.
        """
        if not self._cipher_suite:
            logger.error("Cipher suite not initialized. Cannot decrypt.")
            raise RuntimeError("CryptoProvider cipher suite not initialized.")
        return self._cipher_suite.decrypt(token)

if __name__ == '__main__':
    # Basic logging setup for standalone testing
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    print("--- CryptoProvider Test ---")

    # Test Case 1: Auto mode (should try Fernet, fallback to MockFernet if crypto lib not found)
    print("\n[Test Case 1: Auto Mode]")
    try:
        provider_auto = CryptoProvider(mode="auto")
        print(f"Effective mode (auto): {provider_auto.effective_mode}")
        key_auto = provider_auto.key # Access key via property
        print(f"Generated key (auto mode, {len(key_auto)} bytes): {key_auto[:10]}...") # Print first 10 bytes

        original_data_auto = b"Test data for auto mode"
        encrypted_auto = provider_auto.encrypt(original_data_auto)
        print(f"Encrypted (auto): {encrypted_auto[:20]}...")
        decrypted_auto = provider_auto.decrypt(encrypted_auto)
        print(f"Decrypted (auto): {decrypted_auto}")
        assert original_data_auto == decrypted_auto
        print("Auto mode encrypt/decrypt successful.")

        # Test with a new key generated by the provider
        new_key_auto = provider_auto.generate_key()
        print(f"Newly generated key (auto mode, {len(new_key_auto)} bytes): {new_key_auto[:10]}...")
        assert new_key_auto == provider_auto.key # Check if the provider's key was updated
        original_data_auto_new_key = b"Test data with new key"
        encrypted_auto_new_key = provider_auto.encrypt(original_data_auto_new_key)
        decrypted_auto_new_key = provider_auto.decrypt(encrypted_auto_new_key)
        assert original_data_auto_new_key == decrypted_auto_new_key
        print("Auto mode with new key encrypt/decrypt successful.")

    except Exception as e:
        print(f"Error in auto mode test: {e}")

    # Test Case 2: Mock mode
    print("\n[Test Case 2: Mock Mode]")
    provider_mock = CryptoProvider(mode="mock")
    print(f"Effective mode (mock): {provider_mock.effective_mode}")
    key_mock = provider_mock.key
    print(f"Generated key (mock mode, {len(key_mock)} bytes): {key_mock[:10]}...")

    original_data_mock = b"Test data for mock mode with base64"
    encrypted_mock = provider_mock.encrypt(original_data_mock)
    print(f"Encrypted (mock/base64): {encrypted_mock}")
    decrypted_mock = provider_mock.decrypt(encrypted_mock)
    print(f"Decrypted (mock/base64): {decrypted_mock}")
    assert original_data_mock == decrypted_mock
    print("Mock mode encrypt/decrypt successful.")

    # Test MockFernet directly
    print("\n[Test Case 2b: MockFernet Direct]")
    mock_key_direct = MockFernet.generate_key()
    mock_fernet_direct = MockFernet(mock_key_direct)
    original_data_mock_direct = b"Direct MockFernet test"
    encrypted_mock_direct = mock_fernet_direct.encrypt(original_data_mock_direct)
    decrypted_mock_direct = mock_fernet_direct.decrypt(encrypted_mock_direct)
    assert original_data_mock_direct == decrypted_mock_direct
    print(f"Encrypted (direct mock): {encrypted_mock_direct}")
    print(f"Decrypted (direct mock): {decrypted_mock_direct}")
    print("MockFernet direct encrypt/decrypt successful.")


    # Test Case 3: Fernet mode (will fail if cryptography is not installed)
    print("\n[Test Case 3: Fernet Mode]")
    try:
        provider_fernet = CryptoProvider(mode="fernet")
        print(f"Effective mode (fernet): {provider_fernet.effective_mode}")
        key_fernet = provider_fernet.key
        print(f"Generated key (fernet mode, {len(key_fernet)} bytes): {key_fernet[:10]}...")

        original_data_fernet = b"Test data for fernet mode (real encryption)"
        encrypted_fernet = provider_fernet.encrypt(original_data_fernet)
        print(f"Encrypted (fernet): {encrypted_fernet[:20]}...")
        decrypted_fernet = provider_fernet.decrypt(encrypted_fernet)
        print(f"Decrypted (fernet): {decrypted_fernet}")
        assert original_data_fernet == decrypted_fernet
        print("Fernet mode encrypt/decrypt successful.")
    except ImportError:
        print("Fernet mode test skipped: cryptography library not available.")
    except Exception as e:
        print(f"Error in fernet mode test: {e}")

    # Test Case 4: Using get_cipher_suite with an external key
    print("\n[Test Case 4: get_cipher_suite with external key]")
    try:
        provider_ext = CryptoProvider(mode="auto") # Could be mock or fernet depending on env
        print(f"Provider_ext effective mode: {provider_ext.effective_mode}")

        # Generate a key externally (using the provider's logic for consistency)
        external_key_data = MockFernet.generate_key() if provider_ext.effective_mode == "mock" else None
        if provider_ext.effective_mode == "fernet":
            from cryptography.fernet import Fernet as RealFernetForExtKey
            external_key_data = RealFernetForExtKey.generate_key()

        print(f"Using external key ({len(external_key_data)} bytes): {external_key_data[:10]}...")

        # Get a cipher suite for this external key
        external_cipher = provider_ext.get_cipher_suite(external_key_data)

        original_data_ext = b"Data for external key cipher"
        encrypted_ext = external_cipher.encrypt(original_data_ext)
        print(f"Encrypted (external key, {provider_ext.effective_mode}): {encrypted_ext[:20]}...")
        decrypted_ext = external_cipher.decrypt(encrypted_ext)
        print(f"Decrypted (external key, {provider_ext.effective_mode}): {decrypted_ext}")
        assert original_data_ext == decrypted_ext
        print("get_cipher_suite with external key encrypt/decrypt successful.")

        # Ensure the provider's own key hasn't changed
        assert provider_ext.key != external_key_data # Assuming generate_key creates unique keys
        print("Provider's internal key remains unchanged after using get_cipher_suite with external key.")

    except Exception as e:
        print(f"Error in get_cipher_suite test: {e}")
        import traceback
        traceback.print_exc()

    print("\n--- CryptoProvider Test Complete ---")
    # Example of how MockFernet handles bad token
    print("\n[Test Case 5: MockFernet bad token]")
    bad_token = b"this is not valid base64!@#"
    mock_key_bad = MockFernet.generate_key()
    mf_bad = MockFernet(mock_key_bad)
    try:
        mf_bad.decrypt(bad_token)
    except ValueError as ve:
        print(f"Caught expected error for bad token: {ve}")
    except Exception as ex: # Should be ValueError ideally
        print(f"Caught an error for bad token, but was not ValueError: {type(ex).__name__} - {ex}")


    # Test key property initialization
    print("\n[Test Case 6: Key property initialization]")
    provider_key_test = CryptoProvider(mode="mock") # No key passed initially
    # Accessing the .key property should trigger key generation if not already done
    first_key_access = provider_key_test.key
    assert first_key_access is not None
    print(f"Key after first access (mock): {first_key_access[:10]}...")
    second_key_access = provider_key_test.key
    assert first_key_access == second_key_access # Key should be stable after generation
    print("Key property initialization and stability test successful.")

    # Test with pre-existing key
    print("\n[Test Case 7: Initialization with pre-existing key]")
    pre_key = MockFernet.generate_key()
    provider_pre_key = CryptoProvider(mode="mock", key=pre_key)
    assert provider_pre_key.key == pre_key
    print(f"Provider initialized with pre-existing key: {provider_pre_key.key[:10]}...")
    original_data_pre_key = b"Test with pre-key"
    encrypted_pre_key = provider_pre_key.encrypt(original_data_pre_key)
    decrypted_pre_key = provider_pre_key.decrypt(encrypted_pre_key)
    assert original_data_pre_key == decrypted_pre_key
    print("Encrypt/decrypt with pre-existing key successful.")
    print("--- All Crypto Tests Done ---")
